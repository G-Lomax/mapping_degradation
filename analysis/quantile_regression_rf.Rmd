---
title: "Quantile Regression of Rangeland Productivity - Quantile Regression Forests"
output: html_notebook
author: Guy Lomax
date: 2023-06-19
---

This Notebook conducts quantile regression on rangeland productivity data
using Quantile Regression Forests (QRF), modelling annual gross primary
productivity (GPP) as a function of environmental variables


```{r setup, include = FALSE}

# Data handling
library(tidyverse)
library(sf)
library(here)

# Analysis
library(mlr3verse)
library(mlr3spatiotempcv)
library(ranger)
library(parallel)
library(beepr)

# Visualisation
library(tmap)
library(mlr3viz)

nc <- 4
cl <- makeCluster(nc)

tmap_options(check.and.fix = TRUE)


```


```{r load, include = FALSE}

countries <- st_read(here("data", "raw", "vector", "natural_earth",
                          "ne_110m_admin_0_countries_fixed.shp"))

ke_tz <- countries %>% filter(NAME %in% c("Kenya", "Tanzania"))

sample_points_raw <- st_read(here("data", "raw", "vector", "coarse",
                                  "coarseScaleSample.geojson"))

twi <- read_csv(here("data", "processed", "csv", "twi_sample.csv"))

# ecoregions <- st_read(here("data", "raw", "vector", "coarse", "Ecoregions2017",
#                                   "Ecoregions2017.shp"))
# 
# rangeland_ecoregions <- filter(ecoregions, ECO_ID %in% c(50, 51, 55, 57)) %>%
#   mutate(ECO_NAME = str_replace(ECO_NAME, "Commiphora ", "Commiphora\n"))
# 
# # rangeland_ecoregions_ke_tz <- st_intersection(rangeland_ecoregions, ke_tz)

```


```{r clean, include = FALSE}

sample_points <- sample_points_raw %>%
  mutate(x = st_coordinates(geometry)[,1],
         y = st_coordinates(geometry)[,2]) %>%
  bind_cols(twi) %>%
  mutate(meanT = meanT * 0.1) %>%
  rename(riverDist = first,
         twi = hydrosheds_twi_dinf) %>%
  pivot_longer(cols = starts_with(c("GPP","precipitation", "tMean", "parMean")),
               names_to = "index", values_to = "value") %>%
  separate_wider_delim(index, "_", names = c("data", "year")) %>%
  pivot_wider(names_from = data, values_from = value) %>%
  mutate(year = as.numeric(year)) %>%
  filter(GPP > 0)

# Merge tree and shrub fractions into "woody" fraction

sample_points_woody <- sample_points %>%
  mutate(woody = trees + shrubland) %>%
  select(-trees, -shrubland)

```


# Exploratory data analysis

```{r eda}

# Study area map

tm_shape(ke_tz) + tm_borders() +
  tm_shape(rangeland_ecoregions) + tm_fill(col = "ECO_NAME", style = "cat", palette = "Accent") +
  tm_shape(sample_points_raw) + tm_dots(col = "brown")

# Relative fractions of trees, shrubs, grass

ggtern(sample_points) + geom_point(aes(x = grassland, y = shrubland, z = trees), size = 0.1)

sum(sample_points$shrubland > 0.8) / nrow(sample_points)

# GPP-PPT relationship for different fractions of grassland/shrubland

sample_points_woody %>%
  mutate(grass_cat = cut_width(grassland, 0.2, boundary = 0)) %>%
ggplot(aes(x = precipitation, y = GPP)) +
  geom_point(size = 0.2, alpha = 0.2) +
  facet_wrap(~grass_cat) +
  theme_bw() +
  xlim(0, 1200) +
  ylim(0, 6000)

# Histogram of woody cover

sample_points_woody %>%
  group_by(id) %>%
  summarise(map = mean(precipitation),
            woody = mean(woody)) %>%
  ggplot(aes(x = woody)) +
  geom_histogram(fill = "palegreen", colour = "darkgreen", bins = 50) +
  theme_bw()

```
Data preparation for RF modelling

```{r data_prep}

# Create task

cols_to_retain <- c("id", "elevation", "riverDist", "woody", "landform", "twi",
                    "tMean", "precipitation", "parMean", "sand", "slope",
                    # "x", "y",
                    "year",
                    "GPP"
                    )
sample_points_subset <- sample_points_woody %>%
  filter(!is.na(twi)) %>%
  select(all_of(cols_to_retain))

tsk_gpp <- as_task_regr(sample_points_subset, target = "GPP",
                       # coordinate_names = c("x", "y"),
                       # coords_as_features = FALSE,
                       crs = "epsg:4326")

tsk_gpp$set_col_roles("id", "group")

# Create learner (ranger random forest)

lrn_ranger <- lrn("regr.ranger", predict_type = "response")

lrn_ranger

# Create resampling strategy

cv10 <- rsmp("cv", folds = 5)




```
Fit simple RF model:

```{r rf_model}

# Train model on training set
lrn_ranger$train(tsk_qr, row_ids = splits$train)
beep(3)

# Predict to test set
predictions <- lrn_ranger$predict(tsk_qr, row_ids = splits$test)

predictions

autoplot(predictions)

# Evaluate model performance
measures <- msrs(c("regr.mae", "regr.rmse"))

predictions$score(measures)

# Compare to featureless learner (sample median)

lrn_featureless <- lrn("regr.featureless")
lrn_featureless$train(tsk_gpp, row_ids = splits$train)

lrn_featureless$predict(tsk_gpp, splits$test)$score(measures)

# With resampling

rf_resampled <- resample(tsk_gpp, lrn_ranger, cv10)

rf_resampled$score(measures)
rf_resampled$aggregate(measures)

autoplot(rf_resampled, measure = measures[[2]])

```
For the fun of it, let's try benchmarking performance across multiple learners
and resampling regimes. 

```{r benchmark_models}

learners <- lrns(c("regr.ranger", "regr.nnet", "regr.svm", "regr.featureless"))

design = benchmark_grid(tsk_gpp, learners, cv10)

head(design)

bmr <- benchmark(design)


```

